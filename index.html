<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>X·∫øp H√¨nh Tr√°i Tim ‚Äî S·ª≠a l·ªói</title>
  <style>
    :root {
      --size: 300px;
      --cell: calc(var(--size) / 3);
    }

    body {
      font-family: "Segoe UI", Roboto, sans-serif;
      background: #fff6fb;
      color: #333;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      padding: 24px;
    }

    h1 { color: #d6336c; margin: 0; }
    p { margin: 0 0 12px 0; }

    /* Board (heart-shaped) */
    .board-wrap {
      width: var(--size);
      height: var(--size);
      position: relative;
      /* heart-ish clip-path (simple, works well cross-browser) */
      clip-path: polygon(
        50% 90%,
        10% 55%,
        10% 30%,
        30% 10%,
        50% 30%,
        70% 10%,
        90% 30%,
        90% 55%
      );
      background: linear-gradient(180deg, #fff, #ffeaf2);
      border: 2px solid #ffd6e6;
      box-shadow: 0 6px 18px rgba(198, 38, 112, 0.12);
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* slots laid out in the grid */
    .slot {
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      border: 1px dashed rgba(150,150,150,0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      background: transparent;
      /* allow drops even inside clipped area */
      pointer-events: auto;
    }

    .slot.highlight { outline: 3px dashed rgba(214,51,108,0.45); }

    /* pieces area */
    #pieces {
      width: var(--size);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }

    .piece {
      width: calc(var(--cell) - 8px);
      height: calc(var(--cell) - 8px);
      box-sizing: border-box;
      border: 1px solid #8b8b8b;
      background-image: url("sa1.jpg");
      background-size: var(--size) var(--size); /* full image scaled to board */
      cursor: grab;
      user-select: none;
    }

    /* when a piece is placed inside a slot, make it fill the slot */
    .slot .piece {
      width: 100%;
      height: 100%;
      border: none;
      cursor: default;
    }

    /* small helpers */
    .row { display:flex; gap:8px; }
    button { background:#d6336c; color:white; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; }
  </style>
</head>
<body>
  <h1>üß© X·∫øp H√¨nh Tr√°i Tim</h1>
  <p>K√©o m·∫£nh b√™n d∆∞·ªõi v√†o khung tr√°i tim. N·∫øu l·ªói, load l·∫°i trang v√† th·ª≠ again.</p>

  <div class="board-wrap" id="board" aria-label="khung tr√°i tim">
    <!-- slots s·∫Ω ƒë∆∞·ª£c t·∫°o b·∫±ng JS -->
  </div>

  <div id="pieces" aria-label="m·∫£nh gh√©p"></div>

  <div style="margin-top:8px;">
    <button id="shuffleBtn">X√°o l·∫°i m·∫£nh</button>
    <button id="resetBtn">ƒê·∫∑t l·∫°i</button>
  </div>

  <script>
    const board = document.getElementById("board");
    const piecesContainer = document.getElementById("pieces");
    const gridSize = 3;
    const boardSize = 300; // px, t∆∞∆°ng ·ª©ng v·ªõi --size
    const cellSize = boardSize / gridSize;

    // T·∫°o slots (3x3)
    function createSlots() {
      board.innerHTML = "";
      for (let i = 0; i < gridSize * gridSize; i++) {
        const slot = document.createElement("div");
        slot.className = "slot";
        slot.dataset.index = i;
        slot.addEventListener("dragover", (e) => {
          e.preventDefault();
          slot.classList.add("highlight");
        });
        slot.addEventListener("dragleave", () => slot.classList.remove("highlight"));
        slot.addEventListener("drop", handleDrop);
        board.appendChild(slot);
      }
    }

    // T·∫°o pieces (d·ª±a tr√™n 3x3 ph·∫ßn c·ªßa ·∫£nh)
    function createPieces(shuffle = true) {
      piecesContainer.innerHTML = "";
      const positions = [];
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          positions.push({ r, c, idx: r * gridSize + c });
        }
      }

      if (shuffle) {
        // Fisher-Yates shuffle
        for (let i = positions.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [positions[i], positions[j]] = [positions[j], positions[i]];
        }
      }

      positions.forEach((pos, i) => {
        const piece = document.createElement("div");
        piece.className = "piece";
        piece.id = "p-" + i; // id unique d√πng ƒë·ªÉ truy·ªÅn trong dataTransfer
        // background position: m·ªói m·∫£nh hi·ªÉn th·ªã ƒë√∫ng ph·∫ßn c·ªßa ·∫£nh ƒë·∫ßy ƒë·ªß
        piece.style.backgroundPosition = `-${pos.c * cellSize}px -${pos.r * cellSize}px`;
        // l∆∞u v·ªã tr√≠ ƒë√∫ng ƒë·ªÉ ki·ªÉm tra th·∫Øng
        piece.dataset.correctIndex = pos.idx;
        piece.draggable = true;

        piece.addEventListener("dragstart", (e) => {
          e.dataTransfer.setData("text/plain", piece.id);
          // ƒë·∫∑t effectAllowed ƒë·ªÉ r√µ r√†ng
          e.dataTransfer.effectAllowed = "move";
        });

        piecesContainer.appendChild(piece);
      });
    }

    // X·ª≠ l√Ω drop
    function handleDrop(e) {
      e.preventDefault();
      this.classList.remove("highlight");
      const pieceId = e.dataTransfer.getData("text/plain");
      if (!pieceId) return;
      const dragged = document.getElementById(pieceId);
      if (!dragged) return;

      // N·∫øu slot ƒë√£ c√≥ m·∫£nh th√¨ kh√¥ng cho th·∫£ (b·∫°n c√≥ th·ªÉ thay ƒë·ªïi logic ƒë·ªÉ swap)
      if (this.querySelector(".piece")) return;

      this.appendChild(dragged);
      checkWin();
    }

    // Ki·ªÉm tra th·∫Øng
    function checkWin() {
      const slots = board.querySelectorAll(".slot");
      let win = true;
      slots.forEach((slot, idx) => {
        const piece = slot.querySelector(".piece");
        if (!piece) {
          win = false;
        } else if (parseInt(piece.dataset.correctIndex, 10) !== idx) {
          win = false;
        }
      });

      if (win) {
        setTimeout(() => alert("üéâ B·∫°n ƒë√£ gh√©p xong h√¨nh tr√°i tim r·ªìi!"), 120);
      }
    }

    // Helper: ƒë·∫∑t t·∫•t c·∫£ m·∫£nh tr·ªü l·∫°i v√πng b√™n d∆∞·ªõi (reset)
    function resetPieces() {
      // l·∫•y t·∫•t c·∫£ piece (c√≥ th·ªÉ ƒëang ·ªü trong slot)
      const allPieces = Array.from(document.querySelectorAll(".piece"));
      piecesContainer.innerHTML = "";
      // append l·∫°i theo id order (kh√¥ng c·∫ßn ƒë√∫ng v·ªã tr√≠ g·ªëc)
      allPieces.forEach(p => piecesContainer.appendChild(p));
    }

    // N·∫øu mu·ªën x√°o l·∫°i ho√†n to√†n (t·∫°o l·∫°i pieces)
    document.getElementById("shuffleBtn").addEventListener("click", () => {
      createPieces(true);
    });

    document.getElementById("resetBtn").addEventListener("click", () => {
      createSlots();
      createPieces(false);
    });

    // Kh·ªüi t·∫°o l·∫ßn ƒë·∫ßu
    createSlots();
    createPieces(true);
  </script>
</body>
</html>
